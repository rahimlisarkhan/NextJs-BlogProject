{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getEventsData } from \"../../api/event\";\nimport * as type from '../type'; //find event for router\n\nexport const findEventHandler = (year, month, callback) => {\n  callback(`/events/list/${year}/${month}`);\n};\nexport const getEvents = () => async dispatch => {\n  const res = await getEventsData();\n  const events = [];\n\n  for (const key in res) {\n    events.push(_objectSpread({\n      id: key\n    }, res[key]));\n  }\n\n  dispatch({\n    type: type.GET_EVENTS,\n    payload: events\n  });\n};","map":{"version":3,"sources":["/home/rahimlisarkhan/Documents/NEXT JS LESSON/Practice/NextJs-BlogProject/redux-store/action/index.js"],"names":["getEventsData","type","findEventHandler","year","month","callback","getEvents","dispatch","res","events","key","push","id","GET_EVENTS","payload"],"mappings":";;;;;;AAAA,SAASA,aAAT,QAA8B,iBAA9B;AACA,OAAO,KAAKC,IAAZ,MAAsB,SAAtB,C,CAEA;;AACA,OAAO,MAAMC,gBAAgB,GAAG,CAACC,IAAD,EAAMC,KAAN,EAAYC,QAAZ,KAAwB;AACpDA,EAAAA,QAAQ,CAAE,gBAAeF,IAAK,IAAGC,KAAM,EAA/B,CAAR;AACH,CAFM;AAKP,OAAO,MAAME,SAAS,GAAE,MAAM,MAAMC,QAAN,IAAkB;AAE5C,QAAMC,GAAG,GAAG,MAAMR,aAAa,EAA/B;AAEA,QAAMS,MAAM,GAAG,EAAf;;AAEA,OAAI,MAAMC,GAAV,IAAiBF,GAAjB,EAAqB;AACjBC,IAAAA,MAAM,CAACE,IAAP;AACIC,MAAAA,EAAE,EAACF;AADP,OAEOF,GAAG,CAACE,GAAD,CAFV;AAGM;;AAEVH,EAAAA,QAAQ,CAAC;AAACN,IAAAA,IAAI,EAACA,IAAI,CAACY,UAAX;AAAuBC,IAAAA,OAAO,EAACL;AAA/B,GAAD,CAAR;AAEH,CAdM","sourcesContent":["import { getEventsData } from \"../../api/event\"\nimport * as type from '../type'\n\n//find event for router\nexport const findEventHandler = (year,month,callback) =>{\n    callback(`/events/list/${year}/${month}`)\n} \n\n\nexport const getEvents= () => async dispatch => {\n \n    const res = await getEventsData()\n\n    const events = [];\n\n    for(const key in res){\n        events.push({\n            id:key,\n            ...res[key]}\n            )}\n\n    dispatch({type:type.GET_EVENTS, payload:events})\n    \n}    "]},"metadata":{},"sourceType":"module"}